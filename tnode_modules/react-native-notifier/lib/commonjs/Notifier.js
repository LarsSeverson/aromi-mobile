"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotifierRoot = exports.Notifier = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");
var _reactNativeGestureHandler = require("react-native-gesture-handler");
var _NotifierStyles = _interopRequireDefault(require("./Notifier.styles.js"));
var _index = require("./components/index.js");
var _constants = require("./constants.js");
var _FullWindowOverlay = require("./components/FullWindowOverlay.js");
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const Notifier = exports.Notifier = {
  showNotification: () => {},
  hideNotification: () => {},
  clearQueue: () => {}
};
class NotifierRoot extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      Component: _index.Notification,
      swipeEnabled: _constants.DEFAULT_SWIPE_ENABLED,
      componentProps: {}
    };
    this.isShown = false;
    this.isHiding = false;
    this.hideTimer = null;
    this.showParams = null;
    this.callStack = [];
    this.hiddenComponentValue = -_constants.DEFAULT_COMPONENT_HEIGHT;
    this.translateY = new _reactNative.Animated.Value(_constants.MIN_TRANSLATE_Y);
    this.translateYInterpolated = this.translateY.interpolate({
      inputRange: [_constants.MIN_TRANSLATE_Y, _constants.MAX_TRANSLATE_Y],
      outputRange: [_constants.MIN_TRANSLATE_Y, _constants.MAX_TRANSLATE_Y],
      extrapolate: 'clamp'
    });
    this.onGestureEvent = _reactNative.Animated.event([{
      nativeEvent: {
        translationY: this.translateY
      }
    }], {
      useNativeDriver: true
    });
    this.onPress = this.onPress.bind(this);
    this.onHandlerStateChange = this.onHandlerStateChange.bind(this);
    this.onLayout = this.onLayout.bind(this);
    this.showNotification = this.showNotification.bind(this);
    this.hideNotification = this.hideNotification.bind(this);
    this.clearQueue = this.clearQueue.bind(this);
    if (!props.omitGlobalMethodsHookup) {
      Notifier.showNotification = this.showNotification;
      Notifier.hideNotification = this.hideNotification;
      Notifier.clearQueue = this.clearQueue;
    }
  }
  componentWillUnmount() {
    clearTimeout(this.hideTimer);
  }
  hideNotification(callback) {
    if (!this.isShown || this.isHiding) {
      return;
    }
    _reactNative.Animated.timing(this.translateY, {
      toValue: this.hiddenComponentValue,
      easing: this.showParams?.hideEasing ?? this.showParams?.easing,
      duration: this.showParams?.hideAnimationDuration ?? this.showParams?.animationDuration ?? _constants.DEFAULT_ANIMATION_DURATION,
      useNativeDriver: true
    }).start(result => {
      this.onHidden();
      callback?.(result);
    });
    this.onStartHiding();
  }
  showNotification(functionParams) {
    const {
      // Remove "omitGlobalMethodsHookup" prop as it is only utilized within the constructor and is redundant elsewhere.
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      omitGlobalMethodsHookup,
      // Remove "useRNScreensOverlay" and "rnScreensOverlayViewStyle" as it is only used in the render
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      useRNScreensOverlay,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      rnScreensOverlayViewStyle,
      ...props
    } = this.props;
    const params = {
      ...props,
      ...functionParams,
      componentProps: {
        ...props?.componentProps,
        ...functionParams?.componentProps
      }
    };
    if (this.isShown) {
      switch (params.queueMode) {
        case 'standby':
          {
            this.callStack.push(params);
            break;
          }
        case 'next':
          {
            this.callStack.unshift(params);
            break;
          }
        case 'immediate':
          {
            this.callStack.unshift(params);
            this.hideNotification();
            break;
          }
        default:
          {
            this.callStack = [params];
            this.hideNotification();
            break;
          }
      }
      return;
    }
    const {
      title,
      description,
      swipeEnabled,
      Component,
      componentProps,
      translucentStatusBar,
      containerStyle,
      containerProps,
      onShown,
      ...restParams
    } = params;
    this.setState({
      title,
      description,
      Component: Component ?? _index.Notification,
      swipeEnabled: swipeEnabled ?? _constants.DEFAULT_SWIPE_ENABLED,
      componentProps: componentProps,
      translucentStatusBar,
      containerStyle,
      containerProps
    });
    this.showParams = restParams;
    this.isShown = true;
    this.setHideTimer();
    this.translateY.setValue(-_constants.DEFAULT_COMPONENT_HEIGHT);
    _reactNative.Animated.timing(this.translateY, {
      toValue: _constants.MAX_TRANSLATE_Y,
      easing: this.showParams?.showEasing ?? this.showParams?.easing,
      duration: this.showParams?.showAnimationDuration ?? this.showParams?.animationDuration ?? _constants.DEFAULT_ANIMATION_DURATION,
      useNativeDriver: true
    }).start(onShown);
  }
  clearQueue(hideDisplayedNotification) {
    this.callStack = [];
    if (hideDisplayedNotification) {
      this.hideNotification();
    }
  }
  setHideTimer() {
    const {
      duration = _constants.DEFAULT_DURATION
    } = this.showParams ?? {};
    clearTimeout(this.hideTimer);
    if (duration && !isNaN(duration)) {
      this.hideTimer = setTimeout(this.hideNotification, duration);
    }
  }
  onStartHiding() {
    this.showParams?.onStartHiding?.();
    this.isHiding = true;
    clearTimeout(this.hideTimer);
  }
  onHidden() {
    this.showParams?.onHidden?.();
    this.isShown = false;
    this.isHiding = false;
    this.showParams = null;
    this.translateY.setValue(_constants.MIN_TRANSLATE_Y);
    const nextNotification = this.callStack.shift();
    if (nextNotification) {
      this.showNotification(nextNotification);
    }
  }
  onHandlerStateChange({
    nativeEvent
  }) {
    if (nativeEvent.state === _reactNativeGestureHandler.State.ACTIVE) {
      clearTimeout(this.hideTimer);
    }
    if (nativeEvent.oldState !== _reactNativeGestureHandler.State.ACTIVE) {
      return;
    }
    this.setHideTimer();
    const swipePixelsToClose = -(this.showParams?.swipePixelsToClose ?? _constants.SWIPE_PIXELS_TO_CLOSE);
    const isSwipedOut = nativeEvent.translationY < swipePixelsToClose;
    _reactNative.Animated.timing(this.translateY, {
      toValue: isSwipedOut ? this.hiddenComponentValue : _constants.MAX_TRANSLATE_Y,
      easing: this.showParams?.swipeEasing,
      duration: this.showParams?.swipeAnimationDuration ?? _constants.SWIPE_ANIMATION_DURATION,
      useNativeDriver: true
    }).start(() => {
      if (isSwipedOut) {
        this.onHidden();
      }
    });
    if (isSwipedOut) {
      this.onStartHiding();
    }
  }
  onPress() {
    this.showParams?.onPress?.();
    if (this.showParams?.hideOnPress !== false) {
      this.hideNotification();
    }
  }
  onLayout({
    nativeEvent
  }) {
    const heightWithMargin = nativeEvent.layout.height + 50;
    this.hiddenComponentValue = -Math.max(heightWithMargin, _constants.DEFAULT_COMPONENT_HEIGHT);
  }
  render() {
    const {
      useRNScreensOverlay,
      rnScreensOverlayViewStyle
    } = this.props;
    const {
      title,
      description,
      swipeEnabled,
      Component,
      componentProps,
      translucentStatusBar,
      containerStyle,
      containerProps
    } = this.state;
    const additionalContainerStyle = typeof containerStyle === 'function' ? containerStyle(this.translateY) : containerStyle;
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_FullWindowOverlay.FullWindowOverlay, {
      useOverlay: useRNScreensOverlay,
      viewStyle: rnScreensOverlayViewStyle,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeGestureHandler.PanGestureHandler, {
        enabled: swipeEnabled,
        onGestureEvent: this.onGestureEvent,
        onHandlerStateChange: this.onHandlerStateChange,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Animated.View, {
          ...containerProps,
          style: [_NotifierStyles.default.container, {
            transform: [{
              translateY: this.translateYInterpolated
            }]
          }, additionalContainerStyle],
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeGestureHandler.TouchableWithoutFeedback, {
            onPress: this.onPress,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
              onLayout: this.onLayout,
              style: _reactNative.Platform.OS === 'android' && translucentStatusBar ? _NotifierStyles.default.translucentStatusBarPadding : undefined,
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
                title: title,
                description: description,
                ...componentProps
              })
            })
          })
        })
      })
    });
  }
}
exports.NotifierRoot = NotifierRoot;
//# sourceMappingURL=Notifier.js.map